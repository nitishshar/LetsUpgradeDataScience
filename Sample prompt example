Looking at this prompt for generating Spark SQL code from data quality rules, I can see several areas that need strengthening to ensure the LLM follows your requirements. Here’s a more refined version:

```python
def build_instructional_llm_prompt(
    rule_text,
    rule_name,
    subdimension,
    new_mapping_dict,
    output_code_language,
    output_rule_code_template,
    output_rule_code_example
):
    """
    Build a clear, instructional prompt for LLM to generate Spark SQL code snippets for data quality rules.
    """
    
    prompt = f"""Convert a natural language data quality rule into SQL or a code clause using a language model, with awareness of physical schema context.

Parameters
----------
:param rule_text: {rule_text}
:param rule_name: {rule_name}
:param subdimension: {subdimension}
:param mappings: {json.dumps(new_mapping_dict, indent=2)}
:param output_code_language: {output_code_language}
:param output_rule_code_template: {output_rule_code_template}
:param output_rule_code_example: {output_rule_code_example}

CRITICAL REQUIREMENTS - READ CAREFULLY:

1. COLUMN COUNT AND ORDER (NON-NEGOTIABLE):
   - The SELECT clause MUST contain EXACTLY the same number of columns as shown in output_rule_code_example
   - The columns MUST appear in EXACTLY the same order as output_rule_code_example
   - The columns MUST use EXACTLY the same aliases as output_rule_code_example
   - Count the columns in the example before you begin: if there are 7 columns in the example, your output MUST have exactly 7 columns
   - DO NOT add new columns. DO NOT remove any columns. DO NOT reorder columns.
   - Verify your column count matches the example before returning the SQL

2. MAPPING USAGE (MANDATORY):
   - The mappings dictionary maps business terms in rule_text to physical database column names
   - Business terms in rule_text are enclosed in <> brackets
   - You MUST replace every <business_term> with its corresponding physical column from the mappings
   - For source system fields, use exact column names from the mapping, not generic names
   - Example: If mapping contains "pk_col": "ARRANGEMENT_SK", then use ARRANGEMENT_SK as the column name, not pk_col

3. SPECIAL COLUMNS (MUST INCLUDE):
   - Three columns require special handling: `STD_ARRANGEMENT_ID`, `STD_FINANCIAL_MARKET_POSITION_ID`, and `UITID`
   - Check the "Target Schema" section of the mappings for these columns
   - If a mapping value is present and non-empty for these columns, use that value in the SELECT clause
     Example: If mapping has "std_arrangement_id": "STD_ARRANGEMENT", use STD_ARRANGEMENT in SELECT
   - If a mapping value is missing, empty, null, or blank, use NULL AS <column_name>
     Example: If mapping has "uitid": "", use NULL AS UITID in SELECT
   - NEVER use the column name alone if the value is missing or empty
   - NEVER omit these columns from the SELECT clause
   - These columns must appear in the exact positions shown in the example

4. VERSION FILTERING:
   - For version filtering, always use: WHERE <pc_version LIKE '%version%' from mapping
   - If you need to check multiple versions, use OR between versions
   - Use LIKE '%X%' OR <pc_version LIKE '%Y%' in the WHERE clause
   - Ensure there are no placeholder names like <column_name> or <table_name> in final SQL

5. SQL STRUCTURE MATCHING:
   - The SQL output MUST match the structure and conventions of output_rule_code_example exactly
   - Use mappings to map business terms to physical table and column names
   - For system columns, always use the alias from the example, e.g.:
     * SOURCE_RECORD_PRODUCT_TYPE AS product
     * SOURCE_SYSTEM_ID AS src_system_id
     * SOURCE_SYSTEM_NAME AS src_system
     * REGION_CODE AS region_cd
     * DWH_BUSINESS_DATE AS fact_dwh_business_date
   - Use the value of "Target Table" from the "Target Schema" section as the table name
   - Use the value of "Target Column" from the "Target Schema" section as the physical column
   - For flow entity columns, use the mapping value from pk_col column
   - Do NOT use placeholders like {{primary_key_name}}, {{table_name}}, {{physical_column}}, {{uitid}}, {{std_arrangement_id}}, or {{std_financial_market_position_id}}
   - Replace ALL placeholders with actual values from the mapping or NULL as instructed

6. NULL HANDLING IN SELECT:
   - If the mapping contains a non-empty value for a column, use that value in SELECT
   - If the mapping does NOT contain a value (missing, empty, null, or blank), use NULL AS <column_name>
   - Do not guess, infer, or use default values for missing mapping values
   - Do not use column name alone (e.g., STD_FINANCIAL_MARKET_POSITION_ID) if mapping is missing
   - Examples:
     * If "std_arrangement_id": "" in mapping → use NULL AS STD_ARRANGEMENT_ID
     * If "std_financial_market_position_id": "" in mapping → use NULL AS STD_FINANCIAL_MARKET_POSITION_ID
     * If "uitid": "UITID" in mapping → use UITID AS UITID
     * If "uitid": "" in mapping → use NULL AS UITID

7. VALIDITY RULES:
   - For validity rules, only check values when NOT NULL
   - Always add a not null check: column IS NOT NULL AND <your_condition>
   - Always cast columns as STRING before comparing to range values
   - Enclose range values in '', e.g.: WHERE NVL(CAST(column AS STRING), '') != '' AND (CAST(column AS STRING) NOT IN ('1', '2', '3'))
   - For "Fail if <Business Term> is not between X and Y" rules, generate:
     AND <physical_column> IS NOT NULL
     AND (
       CAST(<physical_column> AS INTEGER) < X
       OR CAST(<physical_column> AS INTEGER) > Y
     )
   - For domain sets (valid values for different schemas), enclose each set in parentheses, comma-separated
   - Fill valid values based on rule_text

8. GENERAL SQL RULES:
   - For null checks, use NVL(CAST(column AS STRING), '') != '' for proper Spark SQL handling
   - For not null checks, use NVL(CAST(column AS STRING), '') != ''
   - Always use CAST when using NVL to check for null vs not null
   - Ensure balanced parentheses in generated SQL code
   - Always use SELECT clause from output_rule_code_example as template
   - Do not add, remove, or reorder columns from the SELECT clause
   - Only replace placeholder values with mapped values or NULL as instructed
   - If a value is missing from mapping, use NULL AS <column_name>
   - Use exact column aliases from the example
   - The version filter should appear only once in each WHERE clause

9. FINAL VERIFICATION CHECKLIST:
   Before returning SQL, verify:
   ✓ Column count matches output_rule_code_example exactly
   ✓ Column order matches output_rule_code_example exactly
   ✓ Column aliases match output_rule_code_example exactly
   ✓ All business terms <> have been replaced with physical columns from mappings
   ✓ STD_ARRANGEMENT_ID, STD_FINANCIAL_MARKET_POSITION_ID, and UITID are handled per rule 3
   ✓ No placeholders remain (no {{}} syntax anywhere)
   ✓ Missing mapping values use NULL AS <column_name>
   ✓ All aliases match example
   ✓ No columns are omitted

OUTPUT FORMAT:
Return only the code without explanations.
Format the code snippet as follows:

{output_rule_code_template}

"""
    return prompt
```

**Key improvements:**

1. **Explicit column count requirements** with verification checklist
1. **Numbered critical requirements** for emphasis and clarity
1. **Specific examples** for each mapping scenario (present vs. missing values)
1. **Clear NULL handling rules** with concrete examples
1. **Bold/uppercase emphasis** on non-negotiable requirements
1. **Final verification checklist** before output
1. **Repeated reminders** about not adding/removing/reordering columns
1. **More specific instructions** about placeholder replacement
1. **Clearer structure** with section headers

The prompt now explicitly tells the LLM to count columns in the example first, and includes multiple checkpoints to verify compliance before returning the SQL.​​​​​​​​​​​​​​​​
